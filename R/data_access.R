#' Creating a connection to the NFI SQL database
#'
#' Wrapper of \code{\link{dbPool}} to connect to the NFI database
#'
#' By default (no arguments supplied) it allows to access as a guest to the
#' database
#'
#' @param user character with database user, default to "guest"
#' @param password character woth the user password, default to "guest"
#' @param dbname character with the database address
#' @param idleTimeout Idle time in seconds before the connection expires
#'
#' @export
nfi_connect <- function(
  user = 'guest',
  password = 'guest',
  dbname = 'tururu',
  idleTimeout = 3600000
) {
  db_conn <- pool::dbPool(
    drv = RPostgreSQL::PostgreSQL(),
    user = user,
    password = password,
    dbname = dbname,
    idleTimeout = idleTimeout
  )

  return(db_conn)
}

#' Closing connection to the NFI SQL database
#'
#' Wrapper of \code{\link{poolClose}} to close the connection
#'
#' @param conn connection object as generated by \code{\link{nfi_connect}}
#'
#' @export
nfi_close <- function(
  conn
) {
  pool::poolClose(conn)
}

#' Retrieve NFI data as tbl
#'
#' Get the results data by plot (with or without breakdown)
#'
#' Data is retrieved from the postgreSQL db in tbl form
#'
#' @section Functional groups:
#' \code{functional_group} parameter allows to retrieve the table of plots
#'   broken down by the desired group. Allowed values are:
#'   \itemize{
#'     \item{\code{"none"} (No breakdown)}
#'     \item{\code{"species"}}
#'     \item{\code{"simplified_species"}}
#'     \item{\code{"genus"}}
#'     \item{\code{"dec"} (Deciduous/Esclerophyllous/Conifer)}
#'     \item{\code{"bc"} (Broadleaf/Conifer)}
#'   }
#'
#' @param conn pool object to access the tables, as obtained from
#'   \code{\link{nfi_connect}}
#' @param nfi character indicating the nfi version
#' @param functional_group Functional group to retrieve table for,
#'   Default to 'none' (no functional group). See details for more information
#' @param diameter_classes logical indicating if diameter classes are required
#'   (breaking down the table by diameter classes). Default to FALSE.
#' @param .collect Logical indicating if the tbl must be collected locally.
#'   Default to TRUE
#'
#' @export
nfi_results_data <- function(
  conn,
  nfi = c('nfi_2', 'nfi_3', 'nfi_4', 'nfi_2_nfi_3', 'nfi_3_nfi_4'),
  functional_group = "none",
  diameter_classes = FALSE,
  .collect = TRUE
) {

  # nfi version
  nfi <- switch(
    nfi,
    'nfi_2' = 'NFI_2',
    'nfi_3' = 'NFI_3',
    'nfi_4' = 'NFI_4',
    'nfi_2_nfi_3' = 'COMP_NFI2_NFI3',
    'nfi_3_nfi_4' = 'COMP_NFI3_NFI4'
  )

  # diameter classes switch
  if (isTRUE(diameter_classes)) {
    dc <- 'DIAMCLASS_'
  } else {
    dc <- ''
  }

  # functional group
  functional_group <- switch(
    functional_group,
    none = 'PLOT',
    species = 'SPECIES',
    simplified_species = 'SIMPSPECIES',
    genus = 'GENUS',
    dec = 'DEC',
    bc = 'BC',
    parcela = 'parcela'
  )

  # table name
  table_name <- glue::glue(
    "{functional_group}_{nfi}_{dc}RESULTS"
  )

  # collect?
  if (isTRUE(.collect)) {
    res <- tbl(conn, table_name) %>% collect()
  } else {
    res <- tbl(conn, table_name)
  }

  # attribute settings
  attr(res, 'nfi') <- nfi
  # attr(res, 'diamclass') <- diameter_classes

  return(res)

}

#' Filter the nfi_results table
#'
#' Filter the results table by vars in the PLOTS and PLOTS_DYNAMIC tables as
#' well as by columns in the data itself
#'
#' @param nfi_data tbl from \code{\link{nfi_results_data}}
#' @param variables character vector with the variables to filter by
#' @param conn pool connection to the database
#' @param ... Filter expressions, in the same order as \code{variables} argument
#' @param .collect Logical indicating if the tbl must be collected locally.
#'   Default to TRUE
#'
#' @export
nfi_results_filter <- function(
  nfi_data,
  variables,
  conn,
  ...,
  .collect = TRUE
) {

  # capture filter expressions
  dots <- quos(...)

  # var dispatching
  PLOTS_fil_index <- vars_in_PLOTS(variables, conn)
  PLOTS_DYNAMIC_fil_index <- var_in_PLOTS_DYNAMIC(
    variables, attr(nfi_data, 'nfi'), conn
  )
  data_fil_index <- which(variables %in% names(nfi_data))

  # filters
  dplyr::tbl(conn, 'PLOTS') %>%
    dplyr::filter(!!! dots[PLOTS_fil_index]) %>%
    dplyr::select(plot_id) -> PLOTS_plots

  dplyr::tbl(conn, glue::glue("PLOTS_{attr(nfi_data, 'nfi')}_DYNAMIC_INFO")) %>%
    dplyr::filter(!!! dots[PLOTS_DYNAMIC_fil_index]) %>%
    dplyr::select(plot_id) -> PLOTS_DYNAMIC_plots


  # if data is collected, we need to collect also the plots and plots_dynamic
  # before joining
  if (any(class(nfi_data) == 'tbl_df')) {
    PLOTS_plots <- collect(PLOTS_plots)
    PLOTS_DYNAMIC_plots <- collect(PLOTS_DYNAMIC_plots)
  }

  # inner joins to get only the records wanted
  nfi_data %>%
    dplyr::filter(!!! dots[data_fil_index]) %>%
    dplyr::inner_join(PLOTS_plots, by = 'plot_id') %>%
    dplyr::inner_join(PLOTS_DYNAMIC_plots, by = 'plot_id') -> res

  if (!isTRUE(.collect)) {
    if (any(class(nfi_data) == 'tbl_df')) {
      warning(
        ".collect set to FALSE, but nfi_data already collected. Returning collected filter results"
      )
    }
  }

  if (isTRUE(.collect) & any(class(nfi_data) == 'tbl_sql')) {
    res <- collect(res)
  }

  return(res)

}